import random
import string
import numpy as np
from typing import Optional
# Assuming Node is correctly found relative to the project structure when tests are run.
# This relies on utils/tests.py (or another runner) adding the parent directory to sys.path.
from tree_analyzer import Node # This should resolve if project root is in sys.path

class TreeGenerator:
    """
    Generates various types of trees and forests for performance testing and examples.
    This includes balanced, wide, random, cyclic trees, and forests with shared nodes.
    """

    def __init__(self, seed: int = 42):
        """
        Initializes the TreeGenerator with a specific seed for reproducibility.

        Args:
            seed (int, optional): The seed for random number generators. Defaults to 42.
        """
        random.seed(seed)
        np.random.seed(seed)

    def generate_random_value(self, length: int = 3) -> str:
        """
        Generates a random string value for a node.

        Args:
            length (int, optional): The length of the random string. Defaults to 3.

        Returns:
            str: A random string composed of uppercase letters and digits.
        """
        return ''.join(random.choices(string.ascii_uppercase + string.digits, k=length))

    def create_balanced_tree(self, depth: int, branching_factor: int = 3) -> Node:
        """
        Creates a balanced tree of a specified depth and branching factor.
        In a balanced tree, each node (except at the maximum depth) has the same number of children.

        Args:
            depth (int): The maximum depth of the tree. Root is at depth 0.
            branching_factor (int, optional): The number of children each node will have. Defaults to 3.

        Returns:
            Node: The root node of the generated balanced tree.
        """
        root = Node(self.generate_random_value())

        def build_level(node: Node, current_depth: int):
            if current_depth >= depth:
                return

            for _ in range(branching_factor):
                child = Node(self.generate_random_value())
                node.add_child(child)
                build_level(child, current_depth + 1)

        build_level(root, 0)
        return root

    def create_wide_tree(self, width: int, depth: int = 3) -> Node:
        """
        Creates a wide tree, where nodes at shallower depths have more children.
        The number of children decreases with depth.

        Args:
            width (int): The number of children for the root node.
            depth (int, optional): The maximum depth of the tree. Defaults to 3.

        Returns:
            Node: The root node of the generated wide tree.
        """
        root = Node(self.generate_random_value())

        def build_wide_level(node: Node, current_depth: int, current_width: int):
            if current_depth >= depth:
                return

            for _ in range(current_width):
                child = Node(self.generate_random_value())
                node.add_child(child)
                # Reduce width for the next level
                build_wide_level(child, current_depth + 1, max(1, current_width // 2))

        build_wide_level(root, 0, width)
        return root

    def create_random_tree(self, num_nodes: int) -> Optional[Node]:
        """
        Creates a random tree with a specified total number of nodes.
        The tree structure is generated by randomly assigning parents and children.

        Args:
            num_nodes (int): The total number of nodes the tree should have.

        Returns:
            Optional[Node]: The root node of the generated random tree, or None if num_nodes is non-positive.
        """
        if num_nodes <= 0:
            return None

        root = Node(self.generate_random_value())
        nodes_list = [root] # List of all nodes created so far to pick parents from
        created_nodes_count = 1

        while created_nodes_count < num_nodes:
            # Choose a random existing node as a parent
            parent_node = random.choice(nodes_list)

            # Create between 1 to 5 children, ensuring not to exceed num_nodes
            num_children_to_create = min(random.randint(1, 5), num_nodes - created_nodes_count)

            for _ in range(num_children_to_create):
                child_node = Node(self.generate_random_value())
                parent_node.add_child(child_node)
                nodes_list.append(child_node)
                created_nodes_count += 1

        return root
    def create_cyclic_tree(self, num_nodes: int, cycle_probability: float = 0.1) -> Optional[Node]:
        """
        Creates a tree that may contain cycles, for testing cycle detection algorithms.
        A cycle is formed by adding an existing node from the tree as a child to another node.

        Args:
            num_nodes (int): The target number of unique nodes to create (cycles reuse existing nodes).
            cycle_probability (float, optional): The probability of creating a cycle at each step
                                                 where a new child could be added. Defaults to 0.1.

        Returns:
            Optional[Node]: The root node of the generated tree with potential cycles,
                            or None if num_nodes is non-positive.
        """
        if num_nodes <= 0:
            return None

        root = Node(self.generate_random_value())
        all_created_nodes = [root] # List of all unique nodes created
        nodes_count = 1

        while nodes_count < num_nodes:
            parent_node = random.choice(all_created_nodes) # Choose a parent from already created unique nodes

            # Decide whether to create a new child or attempt to form a cycle
            if random.random() > cycle_probability or len(all_created_nodes) < 2: # Ensure enough nodes for a cycle
                child_node = Node(self.generate_random_value())
                parent_node.add_child(child_node)
                all_created_nodes.append(child_node)
                nodes_count += 1
            else:
                # Create a cycle by adding an existing node as a child
                # Exclude the parent itself from being chosen as the cyclic child to avoid direct parent-child cycle here,
                # though other forms of cycles are possible.
                possible_cycle_targets = [n for n in all_created_nodes if n != parent_node]
                if possible_cycle_targets:
                    cyclic_child_node = random.choice(possible_cycle_targets)
                    parent_node.add_child(cyclic_child_node)
                else: # Fallback to creating a new node if no valid cycle target
                    child_node = Node(self.generate_random_value())
                    parent_node.add_child(child_node)
                    all_created_nodes.append(child_node)
                    nodes_count += 1
        return root

    def create_shared_nodes_forest(self, num_trees: int, nodes_per_tree: int, shared_ratio: float = 0.3) -> list[Node]:
        """
        Creates a forest of trees where some nodes are shared between different trees.

        Args:
            num_trees (int): The number of trees to generate in the forest.
            nodes_per_tree (int): The approximate number of nodes each tree should have (including shared ones).
            shared_ratio (float, optional): The approximate proportion of nodes in each tree that should
                                           be drawn from a common pool of shared nodes. Defaults to 0.3.

        Returns:
            list[Node]: A list of root nodes, each representing a tree in the generated forest.
        """
        # Create a pool of shared nodes
        shared_nodes_count = int(nodes_per_tree * shared_ratio)
        shared_nodes_pool = [Node(f"SHARED_{i}") for i in range(shared_nodes_count)]

        trees_roots = []

        for tree_idx in range(num_trees):
            root = Node(f"ROOT_{tree_idx}")
            current_tree_nodes_list = [root] # Nodes belonging to the current tree being built

            # Add unique nodes to this tree
            num_unique_nodes = nodes_per_tree - shared_nodes_count
            if num_unique_nodes < 0: num_unique_nodes = 0 # Ensure not negative

            for i in range(num_unique_nodes):
                node = Node(f"T{tree_idx}_N{i}")
                current_tree_nodes_list.append(node)

            # Add some shared nodes from the pool to this tree
            num_shared_to_add = 0
            if shared_nodes_count > 0 and shared_nodes_pool: # Check if pool is not empty
                # Number of shared nodes to pick for this tree
                num_shared_to_add = random.randint(min(1, len(shared_nodes_pool)), len(shared_nodes_pool))
                # Ensure we don't request more than available if nodes_per_tree is small
                num_shared_to_add = min(num_shared_to_add, shared_nodes_count)

                selected_shared_nodes = random.sample(shared_nodes_pool, num_shared_to_add)
                current_tree_nodes_list.extend(selected_shared_nodes)

            # Randomly connect nodes to form a tree structure (simple approach)
            # The root is already present. Connect other nodes.
            # This logic ensures each node (except root) gets one parent from preceding nodes in the list.
            for i in range(1, len(current_tree_nodes_list)):
                node_to_connect = current_tree_nodes_list[i]
                # Choose a parent from nodes already connected in this tree (those at indices < i)
                parent_node = random.choice(current_tree_nodes_list[:i])

                # Avoid adding the same child instance multiple times to the same parent,
                # though Node.add_child currently allows it.
                # A more robust check would be `if child_node not in parent_node.children:`.
                # For this generator, we assume distinct connections are generally formed by this logic.
                parent_node.add_child(node_to_connect)

            trees_roots.append(root)

        return trees_roots
